# to_musicxml(composition_json_data)
debug=true

root = exports ? this
utils=require './tree_iterators.js'


get_attribute= (composition_data,key) ->
  # TODO: dry
  return null if !composition_data.attributes
  att=_.detect(composition_data.attributes.items, (item) ->
    item.key is key
    )
  return null if !att
  att.value

to_musicxml= (composition_data) ->
  title=get_attribute(composition_data,"Title")
  ary=[]
  measure_ctr=1
  for line in composition_data.lines
    for item in line.items when item.my_type is 'measure'
      ary.push(draw_measure(item,measure_ctr))# if item.my_type is "measure"
      measure_ctr++
  #console.log ary
  musicxml_template= """
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
        <!DOCTYPE score-partwise PUBLIC
    "-//Recordare//DTD MusicXML 3.0 Partwise//EN"
    "http://www.musicxml.org/dtds/partwise.dtd">
            <score-partwise version="3.0">
            <score-header>
<work>
  <work-number></work-number>
    <work-title>#{title}</work-title>
    </work>

            </score-header>

  <part-list>
    <score-part id="P1">
      <part-name>Music</part-name>
    </score-part>
  </part-list>
  <part id="P1">
  #{ary.join(' ')}
  </part>
</score-partwise>
  """
  musicxml_template

draw_clef= ()->
  '''
    <clef>
      <sign>C</sign>
      <line>2</line>
    </clef>
  '''

draw_measure= (measure,ctr) ->
  ary=[]
  for item in all_items(measure)
    
    console.log(item)

  """ 
<measure number="#{ctr}">
    <attributes>
    <divisions>1</divisions>
    <key>
      <fifths>0</fifths>
    </key>
    #{draw_clef() if ctr is 1}
    <time>
      <beats>#{measure.beat_count}</beats>
      <beat-type>4</beat-type>
    </time>
  </attributes>
  <note>
    <pitch>
      <step>C</step>
      <octave>4</octave>
    </pitch>
    <duration>4</duration>
    <type>whole</type>
  </note>
</measure>
  """
all_items_in_line= (line_or_item,items=[]) ->
  # TODO: dry this up
  # return (recursively) items in the line_or_item, delves into the hierarchy
  # looks for an items property and if so, recurses to it.
  # line 
  #   measure
  #     beat
  #       item
  if  (!line_or_item.items)
     return [line_or_item]
  for an_item in line_or_item.items
    do (an_item) =>
      items.push an_item #if !an_item.items?
      items.concat all_items_in_line(an_item,items)
  @log 'all_items_in_line returns', items
  return [line_or_item].concat(items)
  
to_musicxml2= (composition_data) ->

  ary=[]
  in_times=false #hack
  at_beginning_of_first_measure_of_line=false
  dashes_at_beginning_of_line_array=[]
  tied_array=[]

  for line in composition_data.lines
    at_beginning_of_first_measure_of_line=false
    in_times=false #hack
    @log "processing #{line.source}"
    all=[]
    x=all_items_in_line(line,all)
    @log("in to_lilypond, all_items_in_line x=",x)
    last_pitch=null
    for item in all
      if item.my_type in ["pitch","barline","measure"] or item.is_barline
        #emit_tied_array(last_pitch,tied_array,ary) if tied_array.length >0 
      if in_times
        if item.my_type is "beat" or item.my_type is "barline"
          #ary.push "}"
          in_times=false
      @log "processing #{item.source}, my_type is #{item.my_type}"
      if item.my_type=="pitch"
        last_pitch=item  #use this to help render ties better(hopefully)
        if dashes_at_beginning_of_line_array.length > 0
          for dash in dashes_at_beginning_of_line_array
            ary.push normalized_pitch_to_lilypond(dash)
          dashes_at_beginning_of_line_array=[]
        ary.push normalized_pitch_to_lilypond(item) 
      if item.is_barline
        ary.push(lookup_lilypond_barline(item.my_type))
      if item.my_type is "beat"
         beat=item
         if beat.subdivisions not in [0,1,2,4,8,16,32,64,128] and !beat_is_all_dashes(beat)
             @log "odd beat.subdivisions=",beat.subdivisions
             x=2
             if beat.subdivisions is 6
               x=4
             if  beat.subdivisions is 5
               x=4
             ary.push "\\times #{x}/#{beat.subdivisions} { "
             in_times=true #hack
      if item.my_type is "dash"
        if !item.dash_to_tie and item.numerator? #THEN its at beginning of line!
          @log "pushing item onto dashes_at_beginning_of_line_array"
          dashes_at_beginning_of_line_array.push item
        if item.dash_to_tie
          #TODO:review

          ary.push normalized_pitch_to_lilypond(item)
          item=null
      if item? and item.my_type is "measure"
         measure=item
         if measure.is_partial
            ary.push "\\partial 4*#{measure.beat_count} "
      if item? and item.dash_to_tie
        tied_array.push item if item?
    if in_times
      ary.push "}"
      in_times=false
    emit_tied_array(last_pitch,tied_array,ary) if tied_array.length >0 
    ary.push "\\break\n"
  mode = get_attribute(composition_data,'Mode')
  mode or= "major"
  composer = get_attribute(composition_data,"Author")
  composer_snippet=""
  if composer
    composer_snippet= """
      composer = "#{composer}"
     """

  title = get_attribute(composition_data,"Title")
  time = get_attribute(composition_data,"TimeSignature")
  if (key_is_valid=is_valid_key(composition_data.key))
    transpose_snip="\\transpose c' #{composition_data.key}'" 
  else
    transpose_snip=""
    if composition_data.key?
      @log("#{composition_data.key} is invalid")
      composition_data.warnings.push "Invalid key. Valid keys are cdefgab etc. Use a Mode: directive to set the mode(major,minor,aeolian, etc). See the lilypond documentation for more info"
  # Don't transpose non-sargam notation TODO:review
  if ! notation_is_in_sargam(composition_data)
    transpose_snip=""
  time="4/4" if !time
  key_snippet= """
  \\key c \\#{mode}
  """
  if ! notation_is_in_sargam(composition_data) and key_is_valid
    key_snippet= """
    \\key #{composition_data.key} \\#{mode}
    """
  
  title_snippet=""
  if title
    title_snippet= """
      title = "#{title}"



root.to_musicxml=to_musicxml
