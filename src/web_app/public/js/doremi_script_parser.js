DoremiScriptParser = (function(){
  /* Generated by PEG.js 0.6.2 (http://pegjs.majda.cz/). */
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "ABC_A": parse_ABC_A,
        "ABC_AFLAT": parse_ABC_AFLAT,
        "ABC_ASHARP": parse_ABC_ASHARP,
        "ABC_B": parse_ABC_B,
        "ABC_BEAT_DELIMITED": parse_ABC_BEAT_DELIMITED,
        "ABC_BEAT_DELIMITED_ITEM": parse_ABC_BEAT_DELIMITED_ITEM,
        "ABC_BEAT_UNDELIMITED": parse_ABC_BEAT_UNDELIMITED,
        "ABC_BEAT_UNDELIMITED_ITEM": parse_ABC_BEAT_UNDELIMITED_ITEM,
        "ABC_BFLAT": parse_ABC_BFLAT,
        "ABC_BSHARP": parse_ABC_BSHARP,
        "ABC_C": parse_ABC_C,
        "ABC_CFLAT": parse_ABC_CFLAT,
        "ABC_CSHARP": parse_ABC_CSHARP,
        "ABC_D": parse_ABC_D,
        "ABC_DFLAT": parse_ABC_DFLAT,
        "ABC_DSHARP": parse_ABC_DSHARP,
        "ABC_E": parse_ABC_E,
        "ABC_EFLAT": parse_ABC_EFLAT,
        "ABC_F": parse_ABC_F,
        "ABC_FSHARP": parse_ABC_FSHARP,
        "ABC_G": parse_ABC_G,
        "ABC_GFLAT": parse_ABC_GFLAT,
        "ABC_GSHARP": parse_ABC_GSHARP,
        "ABC_MEASURE": parse_ABC_MEASURE,
        "ABC_MUSICAL_CHAR": parse_ABC_MUSICAL_CHAR,
        "ABC_NON_BARLINE": parse_ABC_NON_BARLINE,
        "ABC_SARGAM_CHAR": parse_ABC_SARGAM_CHAR,
        "ABC_SARGAM_LINE": parse_ABC_SARGAM_LINE,
        "ABC_SARGAM_PITCH": parse_ABC_SARGAM_PITCH,
        "ALTERNATE_ENDING_INDICATOR": parse_ALTERNATE_ENDING_INDICATOR,
        "ATTRIBUTE_LINE": parse_ATTRIBUTE_LINE,
        "BARLINE": parse_BARLINE,
        "BEAT_DELIMITED": parse_BEAT_DELIMITED,
        "BEAT_DELIMITED_ITEM": parse_BEAT_DELIMITED_ITEM,
        "BEAT_UNDELIMITED": parse_BEAT_UNDELIMITED,
        "BEAT_UNDELIMITED_ITEM": parse_BEAT_UNDELIMITED_ITEM,
        "BEGIN_BEAT_SYMBOL": parse_BEGIN_BEAT_SYMBOL,
        "BEGIN_SLUR_OF_PITCH": parse_BEGIN_SLUR_OF_PITCH,
        "CHORD_SYMBOL": parse_CHORD_SYMBOL,
        "CHORD_SYMBOL_CHAR": parse_CHORD_SYMBOL_CHAR,
        "CHORD_SYMBOL_INITIAL_CHAR": parse_CHORD_SYMBOL_INITIAL_CHAR,
        "COMPOSITION": parse_COMPOSITION,
        "COMPOUND_LINE": parse_COMPOUND_LINE,
        "DELIMITED_SARGAM_ORNAMENT": parse_DELIMITED_SARGAM_ORNAMENT,
        "DEVANAGRI_BEAT_DELIMITED": parse_DEVANAGRI_BEAT_DELIMITED,
        "DEVANAGRI_BEAT_DELIMITED_ITEM": parse_DEVANAGRI_BEAT_DELIMITED_ITEM,
        "DEVANAGRI_BEAT_UNDELIMITED": parse_DEVANAGRI_BEAT_UNDELIMITED,
        "DEVANAGRI_BEAT_UNDELIMITED_ITEM": parse_DEVANAGRI_BEAT_UNDELIMITED_ITEM,
        "DEVANAGRI_DHA": parse_DEVANAGRI_DHA,
        "DEVANAGRI_GA": parse_DEVANAGRI_GA,
        "DEVANAGRI_MA": parse_DEVANAGRI_MA,
        "DEVANAGRI_MA_SHARP": parse_DEVANAGRI_MA_SHARP,
        "DEVANAGRI_MEASURE": parse_DEVANAGRI_MEASURE,
        "DEVANAGRI_MUSICAL_CHAR": parse_DEVANAGRI_MUSICAL_CHAR,
        "DEVANAGRI_NI": parse_DEVANAGRI_NI,
        "DEVANAGRI_NON_BARLINE": parse_DEVANAGRI_NON_BARLINE,
        "DEVANAGRI_PA": parse_DEVANAGRI_PA,
        "DEVANAGRI_RE": parse_DEVANAGRI_RE,
        "DEVANAGRI_SA": parse_DEVANAGRI_SA,
        "DEVANAGRI_SARGAM_LINE": parse_DEVANAGRI_SARGAM_LINE,
        "DEVANAGRI_SARGAM_PITCH": parse_DEVANAGRI_SARGAM_PITCH,
        "DOUBLE_BARLINE": parse_DOUBLE_BARLINE,
        "EMPTY_LINE": parse_EMPTY_LINE,
        "END_BEAT_SYMBOL": parse_END_BEAT_SYMBOL,
        "END_SLUR": parse_END_SLUR,
        "END_SLUR_OF_PITCH": parse_END_SLUR_OF_PITCH,
        "EOF": parse_EOF,
        "EOL": parse_EOL,
        "FINAL_BARLINE": parse_FINAL_BARLINE,
        "FORWARD_SLASH_CHAR": parse_FORWARD_SLASH_CHAR,
        "HEADER_SECTION": parse_HEADER_SECTION,
        "KOMMAL_INDICATOR": parse_KOMMAL_INDICATOR,
        "LEFT_REPEAT": parse_LEFT_REPEAT,
        "LINE": parse_LINE,
        "LINE_END": parse_LINE_END,
        "LINE_END_CHAR": parse_LINE_END_CHAR,
        "LINE_NUMBER": parse_LINE_NUMBER,
        "LOWER_LOWER_OCTAVE_SYMBOL": parse_LOWER_LOWER_OCTAVE_SYMBOL,
        "LOWER_OCTAVE_DOT": parse_LOWER_OCTAVE_DOT,
        "LOWER_OCTAVE_LINE": parse_LOWER_OCTAVE_LINE,
        "LOWER_OCTAVE_LINE_ITEM": parse_LOWER_OCTAVE_LINE_ITEM,
        "LYRICS_LINE": parse_LYRICS_LINE,
        "MEASURE": parse_MEASURE,
        "MORDENT": parse_MORDENT,
        "NON_BARLINE": parse_NON_BARLINE,
        "NUMBER_A": parse_NUMBER_A,
        "NUMBER_AFLAT": parse_NUMBER_AFLAT,
        "NUMBER_ASHARP": parse_NUMBER_ASHARP,
        "NUMBER_B": parse_NUMBER_B,
        "NUMBER_BEAT_DELIMITED": parse_NUMBER_BEAT_DELIMITED,
        "NUMBER_BEAT_DELIMITED_ITEM": parse_NUMBER_BEAT_DELIMITED_ITEM,
        "NUMBER_BEAT_UNDELIMITED": parse_NUMBER_BEAT_UNDELIMITED,
        "NUMBER_BEAT_UNDELIMITED_ITEM": parse_NUMBER_BEAT_UNDELIMITED_ITEM,
        "NUMBER_BFLAT": parse_NUMBER_BFLAT,
        "NUMBER_BSHARP": parse_NUMBER_BSHARP,
        "NUMBER_C": parse_NUMBER_C,
        "NUMBER_CFLAT": parse_NUMBER_CFLAT,
        "NUMBER_CSHARP": parse_NUMBER_CSHARP,
        "NUMBER_D": parse_NUMBER_D,
        "NUMBER_DFLAT": parse_NUMBER_DFLAT,
        "NUMBER_DSHARP": parse_NUMBER_DSHARP,
        "NUMBER_E": parse_NUMBER_E,
        "NUMBER_EFLAT": parse_NUMBER_EFLAT,
        "NUMBER_ESHARP": parse_NUMBER_ESHARP,
        "NUMBER_F": parse_NUMBER_F,
        "NUMBER_FFLAT": parse_NUMBER_FFLAT,
        "NUMBER_FSHARP": parse_NUMBER_FSHARP,
        "NUMBER_G": parse_NUMBER_G,
        "NUMBER_GFLAT": parse_NUMBER_GFLAT,
        "NUMBER_GSHARP": parse_NUMBER_GSHARP,
        "NUMBER_MEASURE": parse_NUMBER_MEASURE,
        "NUMBER_MUSICAL_CHAR": parse_NUMBER_MUSICAL_CHAR,
        "NUMBER_NON_BARLINE": parse_NUMBER_NON_BARLINE,
        "NUMBER_SARGAM_LINE": parse_NUMBER_SARGAM_LINE,
        "NUMBER_SARGAM_PITCH": parse_NUMBER_SARGAM_PITCH,
        "REPEAT_SYMBOL": parse_REPEAT_SYMBOL,
        "REVERSE_FINAL_BARLINE": parse_REVERSE_FINAL_BARLINE,
        "RHYTHMICAL_DASH": parse_RHYTHMICAL_DASH,
        "RIGHT_REPEAT": parse_RIGHT_REPEAT,
        "SARGAM_DHA": parse_SARGAM_DHA,
        "SARGAM_DHA_FLAT": parse_SARGAM_DHA_FLAT,
        "SARGAM_DHA_SHARP": parse_SARGAM_DHA_SHARP,
        "SARGAM_GA": parse_SARGAM_GA,
        "SARGAM_GA_FLAT": parse_SARGAM_GA_FLAT,
        "SARGAM_GA_SHARP": parse_SARGAM_GA_SHARP,
        "SARGAM_LINE": parse_SARGAM_LINE,
        "SARGAM_LINE_ITEM": parse_SARGAM_LINE_ITEM,
        "SARGAM_MA": parse_SARGAM_MA,
        "SARGAM_MA_SHARP": parse_SARGAM_MA_SHARP,
        "SARGAM_MUSICAL_CHAR": parse_SARGAM_MUSICAL_CHAR,
        "SARGAM_NI": parse_SARGAM_NI,
        "SARGAM_NI_FLAT": parse_SARGAM_NI_FLAT,
        "SARGAM_NI_SHARP": parse_SARGAM_NI_SHARP,
        "SARGAM_ORNAMENT": parse_SARGAM_ORNAMENT,
        "SARGAM_PA": parse_SARGAM_PA,
        "SARGAM_PA_FLAT": parse_SARGAM_PA_FLAT,
        "SARGAM_PA_SHARP": parse_SARGAM_PA_SHARP,
        "SARGAM_PITCH": parse_SARGAM_PITCH,
        "SARGAM_RE": parse_SARGAM_RE,
        "SARGAM_RE_FLAT": parse_SARGAM_RE_FLAT,
        "SARGAM_RE_SHARP": parse_SARGAM_RE_SHARP,
        "SARGAM_SA": parse_SARGAM_SA,
        "SARGAM_SA_FLAT": parse_SARGAM_SA_FLAT,
        "SARGAM_SA_SHARP": parse_SARGAM_SA_SHARP,
        "SIMPLE_LINE": parse_SIMPLE_LINE,
        "SINGLE_BARLINE": parse_SINGLE_BARLINE,
        "SPACE": parse_SPACE,
        "SYLLABLE": parse_SYLLABLE,
        "TALA": parse_TALA,
        "UNDELIMITED_SARGAM_PITCH_WITH_DASHES": parse_UNDELIMITED_SARGAM_PITCH_WITH_DASHES,
        "UPPER_OCTAVE_DOT": parse_UPPER_OCTAVE_DOT,
        "UPPER_OCTAVE_LINE": parse_UPPER_OCTAVE_LINE,
        "UPPER_OCTAVE_LINE_ITEM": parse_UPPER_OCTAVE_LINE_ITEM,
        "UPPER_UPPER_OCTAVE_SYMBOL": parse_UPPER_UPPER_OCTAVE_SYMBOL,
        "WHITE_SPACE": parse_WHITE_SPACE,
        "WORD": parse_WORD,
        "_": parse__
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "COMPOSITION";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      var cache = {};
      var _chunk = {"pos":-1,"end":-1,"match":""};
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function quote(s) {
        /*
         * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
         * string literal except for the closing quote character, backslash,
         * carriage return, line separator, paragraph separator, and line feed.
         * Any character may appear in the form of an escape sequence.
         *
         * For portability, we also escape escape all control and non-ASCII
         * characters. Note that "\0" and "\v" escape sequences are not used
         * because JSHint does not like the first and IE the second.
         */
        return '"' + s
          .replace(/\\/g, '\\\\')  // backslash
          .replace(/"/g, '\\"')    // closing quote character
          .replace(/\x08/g, '\\b') // backspace
          .replace(/\t/g, '\\t')   // horizontal tab
          .replace(/\n/g, '\\n')   // line feed
          .replace(/\f/g, '\\f')   // form feed
          .replace(/\r/g, '\\r')   // carriage return
          .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
          + '"';
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_EMPTY_LINE() {
        var cacheKey = "EMPTY_LINE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2, result3, result4;
        var pos0, pos1, pos2;
        
        if (input.charCodeAt(pos) === 10) {
          result0 = "\n";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\n\"");
          }
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = [];
          if (input.charCodeAt(pos) === 32) {
            result1 = " ";
            pos += 1;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\" \"");
            }
          }
          while (result1 !== null) {
            result0.push(result1);
            if (input.charCodeAt(pos) === 32) {
              result1 = " ";
              pos += 1;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\" \"");
              }
            }
          }
          if (result0 !== null) {
            result1 = parse_LINE_END_CHAR();
            if (result1 !== null) {
              result2 = [];
              pos2 = pos;
              result3 = [];
              if (input.charCodeAt(pos) === 32) {
                result4 = " ";
                pos += 1;
              } else {
                result4 = null;
                if (reportFailures === 0) {
                  matchFailed("\" \"");
                }
              }
              while (result4 !== null) {
                result3.push(result4);
                if (input.charCodeAt(pos) === 32) {
                  result4 = " ";
                  pos += 1;
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\" \"");
                  }
                }
              }
              if (result3 !== null) {
                result4 = parse_LINE_END_CHAR();
                if (result4 !== null) {
                  result3 = [result3, result4];
                } else {
                  result3 = null;
                  pos = pos2;
                }
              } else {
                result3 = null;
                pos = pos2;
              }
              while (result3 !== null) {
                result2.push(result3);
                pos2 = pos;
                result3 = [];
                if (input.charCodeAt(pos) === 32) {
                  result4 = " ";
                  pos += 1;
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\" \"");
                  }
                }
                while (result4 !== null) {
                  result3.push(result4);
                  if (input.charCodeAt(pos) === 32) {
                    result4 = " ";
                    pos += 1;
                  } else {
                    result4 = null;
                    if (reportFailures === 0) {
                      matchFailed("\" \"");
                    }
                  }
                }
                if (result3 !== null) {
                  result4 = parse_LINE_END_CHAR();
                  if (result4 !== null) {
                    result3 = [result3, result4];
                  } else {
                    result3 = null;
                    pos = pos2;
                  }
                } else {
                  result3 = null;
                  pos = pos2;
                }
              }
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          _chunk.pos = pos0;
          _chunk.end = pos;
          _chunk.match = input.substring(pos0,pos);
          if (result0 !== null) {
            result0 = (function(_chunk) { return {my_type: "line_end"}
                     })(_chunk);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_HEADER_SECTION() {
        var cacheKey = "HEADER_SECTION@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result1 = parse_ATTRIBUTE_LINE();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_ATTRIBUTE_LINE();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result2 = parse_EMPTY_LINE();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_EMPTY_LINE();
            }
          } else {
            result1 = null;
          }
          if (result1 === null) {
            result1 = parse_EOF();
            if (result1 === null) {
              if (input.substr(pos, 2) === "/n") {
                result1 = "/n";
                pos += 2;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"/n\"");
                }
              }
              if (result1 === null) {
                pos2 = pos;
                reportFailures++;
                result1 = parse_LINE();
                reportFailures--;
                if (result1 !== null) {
                  result1 = "";
                  pos = pos2;
                } else {
                  result1 = null;
                }
              }
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(attributes, _chunk) { return { my_type:"attributes",
                        items: attributes,
                        source: "TODO"
                        }})(result0[0], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("Headers followed by blank lines or a line");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_COMPOSITION() {
        var cacheKey = "COMPOSITION@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = [];
        result1 = parse_LINE_END_CHAR();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_LINE_END_CHAR();
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_EMPTY_LINE();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_EMPTY_LINE();
          }
          if (result1 !== null) {
            result2 = parse_HEADER_SECTION();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = [];
              result4 = parse_LINE();
              while (result4 !== null) {
                result3.push(result4);
                result4 = parse_LINE();
              }
              if (result3 !== null) {
                result4 = parse_EOF();
                if (result4 === null) {
                  result4 = parse_EMPTY_LINE();
                }
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(attributes, lines, _chunk) { 
                  return parse_composition(attributes,lines)
              })(result0[2], result0[3], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("a musical piece  lines:LINE+ ");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ATTRIBUTE_LINE() {
        var cacheKey = "ATTRIBUTE_LINE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2, result3, result4, result5, result6;
        var pos0, pos1, pos2;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        if (/^[a-zA-Z_\-0-9]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z_\\-0-9]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[a-zA-Z_\-0-9]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[a-zA-Z_\\-0-9]");
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = "";
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 58) {
              result2 = ":";
              pos += 1;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\":\"");
              }
            }
            if (result2 !== null) {
              result3 = parse__();
              if (result3 !== null) {
                if (/^[^\n\r]/.test(input.charAt(pos))) {
                  result5 = input.charAt(pos);
                  pos++;
                } else {
                  result5 = null;
                  if (reportFailures === 0) {
                    matchFailed("[^\\n\\r]");
                  }
                }
                if (result5 !== null) {
                  result4 = [];
                  while (result5 !== null) {
                    result4.push(result5);
                    if (/^[^\n\r]/.test(input.charAt(pos))) {
                      result5 = input.charAt(pos);
                      pos++;
                    } else {
                      result5 = null;
                      if (reportFailures === 0) {
                        matchFailed("[^\\n\\r]");
                      }
                    }
                  }
                } else {
                  result4 = null;
                }
                if (result4 !== null) {
                  result5 = parse__();
                  if (result5 !== null) {
                    result6 = parse_LINE_END_CHAR();
                    if (result6 === null) {
                      pos2 = pos;
                      reportFailures++;
                      result6 = parse_EOF();
                      reportFailures--;
                      if (result6 !== null) {
                        result6 = "";
                        pos = pos2;
                      } else {
                        result6 = null;
                      }
                    }
                    if (result6 !== null) {
                      result0 = [result0, result1, result2, result3, result4, result5, result6];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(key_chars, blanks, value_chars, _chunk) { return { my_type:"attribute",
                        key: key_chars.join(''),
                        value:this.trim(value_chars.join('')),
                        source: "todo"
                        }})(result0[0], result0[3], result0[4], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie Author: John Rothfield");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_LINE_END() {
        var cacheKey = "LINE_END@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        reportFailures++;
        result0 = parse_EOF();
        reportFailures--;
        if (result0 !== null) {
          result0 = "";
          pos = pos0;
        } else {
          result0 = null;
        }
        if (result0 === null) {
          result0 = parse_EOL();
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("eol or eof");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_COMPOUND_LINE() {
        var cacheKey = "COMPOUND_LINE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2, result3, result4, result5, result6;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = [];
        result1 = parse_UPPER_OCTAVE_LINE();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_UPPER_OCTAVE_LINE();
        }
        if (result0 !== null) {
          result1 = parse_DEVANAGRI_SARGAM_LINE();
          if (result1 === null) {
            result1 = parse_SARGAM_LINE();
            if (result1 === null) {
              result1 = parse_ABC_SARGAM_LINE();
              if (result1 === null) {
                result1 = parse_NUMBER_SARGAM_LINE();
              }
            }
          }
          if (result1 !== null) {
            result2 = [];
            result3 = parse_LOWER_OCTAVE_LINE();
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_LOWER_OCTAVE_LINE();
            }
            if (result2 !== null) {
              result3 = parse_LYRICS_LINE();
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result4 = parse_LINE_END();
                if (result4 !== null) {
                  result5 = [];
                  result6 = parse_EMPTY_LINE();
                  while (result6 !== null) {
                    result5.push(result6);
                    result6 = parse_EMPTY_LINE();
                  }
                  if (result5 !== null) {
                    result0 = [result0, result1, result2, result3, result4, result5];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(uppers, sargam, lowers, lyrics, _chunk) {
                  return parse_line(uppers,sargam,lowers,lyrics)
                })(result0[0], result0[1], result0[2], result0[3], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_LINE() {
        var cacheKey = "LINE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        
        reportFailures++;
        result0 = parse_COMPOUND_LINE();
        if (result0 === null) {
          result0 = parse_SIMPLE_LINE();
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("main line of music. multiple lines including syllables etc,delimited by empty line. There is an order, optional upper octave lines followed by main line of sargam followed by optional lyrics line");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SIMPLE_LINE() {
        var cacheKey = "SIMPLE_LINE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_DEVANAGRI_SARGAM_LINE();
        if (result0 === null) {
          result0 = parse_SARGAM_LINE();
          if (result0 === null) {
            result0 = parse_ABC_SARGAM_LINE();
            if (result0 === null) {
              result0 = parse_NUMBER_SARGAM_LINE();
            }
          }
        }
        if (result0 !== null) {
          result1 = [];
          result2 = parse_LOWER_OCTAVE_LINE();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_LOWER_OCTAVE_LINE();
          }
          if (result1 !== null) {
            result2 = parse_LYRICS_LINE();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_LINE_END();
              if (result3 !== null) {
                result4 = [];
                result5 = parse_EMPTY_LINE();
                while (result5 !== null) {
                  result4.push(result5);
                  result5 = parse_EMPTY_LINE();
                }
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(sargam, lowers, lyrics, _chunk) { 
                  uppers=''
                  return parse_line(uppers,sargam,lowers,lyrics)
            })(result0[0], result0[1], result0[2], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SARGAM_ORNAMENT() {
        var cacheKey = "SARGAM_ORNAMENT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        result1 = parse_SARGAM_PITCH();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_SARGAM_PITCH();
          }
        } else {
          result0 = null;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(items, _chunk) { 
                    return parse_ornament("",items,"")
                 })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("in upper line NRSNS");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_DELIMITED_SARGAM_ORNAMENT() {
        var cacheKey = "DELIMITED_SARGAM_ORNAMENT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 60) {
          result0 = "<";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"<\"");
          }
        }
        if (result0 !== null) {
          result2 = parse_SARGAM_PITCH();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_SARGAM_PITCH();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 62) {
              result2 = ">";
              pos += 1;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\">\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(left_delimiter, items, right_delimiter, _chunk) { 
                    return parse_ornament(left_delimiter,items,right_delimiter)
                 })(result0[0], result0[1], result0[2], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("in upper line <NRSNS>");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_UPPER_OCTAVE_LINE() {
        var cacheKey = "UPPER_OCTAVE_LINE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_WHITE_SPACE();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result2 = parse_UPPER_OCTAVE_LINE_ITEM();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_UPPER_OCTAVE_LINE_ITEM();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_WHITE_SPACE();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_LINE_END();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(begin_white_space, items, end_white_space, _chunk) {
                 my_items =  _.compact(_.flatten([begin_white_space, items,end_white_space]))
               return {
                       my_type:"upper_octave_line",
                       source: this.get_source_for_items(my_items),
                       items: my_items
                      } 
              })(result0[0], result0[1], result0[2], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("can put upper octave dots or semicolons for upper upper octave (. or :). Also tala symbols +203");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_FORWARD_SLASH_CHAR() {
        var cacheKey = "FORWARD_SLASH_CHAR@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        
        reportFailures++;
        if (input.charCodeAt(pos) === 47) {
          result0 = "/";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/\"");
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("note that putting forward slash in regex doesn't seem to work");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_CHORD_SYMBOL_CHAR() {
        var cacheKey = "CHORD_SYMBOL_CHAR@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        
        if (/^[a-gA-GmiMaIivV0-9+]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-gA-GmiMaIivV0-9+]");
          }
        }
        if (result0 === null) {
          result0 = parse_FORWARD_SLASH_CHAR();
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_CHORD_SYMBOL_INITIAL_CHAR() {
        var cacheKey = "CHORD_SYMBOL_INITIAL_CHAR@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        
        if (/^[a-gA-GvViI]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-gA-GvViI]");
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_CHORD_SYMBOL() {
        var cacheKey = "CHORD_SYMBOL@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2, result3;
        var pos0, pos1, pos2, pos3;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        pos2 = pos;
        reportFailures++;
        pos3 = pos;
        if (/^[SrRgGmMPdDnN]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[SrRgGmMPdDnN]");
          }
        }
        if (result0 !== null) {
          if (/^[SrRgGmMPdDnN]/.test(input.charAt(pos))) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("[SrRgGmMPdDnN]");
            }
          }
          if (result1 !== null) {
            if (/^[SrRgGmMPdDnN]/.test(input.charAt(pos))) {
              result2 = input.charAt(pos);
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("[SrRgGmMPdDnN]");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos3;
            }
          } else {
            result0 = null;
            pos = pos3;
          }
        } else {
          result0 = null;
          pos = pos3;
        }
        reportFailures--;
        if (result0 === null) {
          result0 = "";
        } else {
          result0 = null;
          pos = pos2;
        }
        if (result0 !== null) {
          result1 = parse_CHORD_SYMBOL_INITIAL_CHAR();
          if (result1 !== null) {
            result2 = [];
            result3 = parse_CHORD_SYMBOL_CHAR();
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_CHORD_SYMBOL_CHAR();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(initial, chars, _chunk) {
                      source=initial + chars.join('')
                      return {
                       my_type:"chord_symbol",
                       source: source, 
                      } 
          })(result0[1], result0[2], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("I IV V. Put in lookahead for 3 sargam chars. ");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ALTERNATE_ENDING_INDICATOR() {
        var cacheKey = "ALTERNATE_ENDING_INDICATOR@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        if (/^[1-3]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[1-3]");
          }
        }
        if (result0 !== null) {
          if (/^[._]/.test(input.charAt(pos))) {
            result2 = input.charAt(pos);
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[._]");
            }
          }
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              if (/^[._]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[._]");
                }
              }
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(num, underscores, _chunk) {
                    if (typeof(dot) == 'undefined') {
                      dot=''
                    }
                    if (typeof(underscores) == 'undefined') {
                      underscores=[]
                    }
                    source=_.flatten([num,dot,underscores]).join('')
                    return {
                      my_type: "ending",
                      source:source,
                      num:parseInt(num)
              }
            })(result0[0], result0[1], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("1._______ 2.___ etc. The period is optional. Must have either dot or underscores. TODO: accepts 1_.___ which is not exactly what I want.");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_UPPER_OCTAVE_LINE_ITEM() {
        var cacheKey = "UPPER_OCTAVE_LINE_ITEM@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        
        reportFailures++;
        result0 = parse_DELIMITED_SARGAM_ORNAMENT();
        if (result0 === null) {
          result0 = parse_WHITE_SPACE();
          if (result0 === null) {
            result0 = parse_UPPER_OCTAVE_DOT();
            if (result0 === null) {
              result0 = parse_ALTERNATE_ENDING_INDICATOR();
              if (result0 === null) {
                result0 = parse_TALA();
                if (result0 === null) {
                  result0 = parse_MORDENT();
                  if (result0 === null) {
                    result0 = parse_UPPER_UPPER_OCTAVE_SYMBOL();
                    if (result0 === null) {
                      result0 = parse_CHORD_SYMBOL();
                      if (result0 === null) {
                        result0 = parse_SARGAM_ORNAMENT();
                      }
                    }
                  }
                }
              }
            }
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("Things above notes, including talas, octaves,chords, and 1st and second ending symbols");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_LOWER_OCTAVE_LINE() {
        var cacheKey = "LOWER_OCTAVE_LINE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result1 = parse_LOWER_OCTAVE_LINE_ITEM();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_LOWER_OCTAVE_LINE_ITEM();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = parse_LINE_END();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(items, _chunk) {
               my_items =  _.flatten(items)
               if (my_items.length == 0) {
                 return ""
               }
               return {
                       my_type:"lower_octave_line",
                       source: this.get_source_for_items(items),
                       items: my_items
                      } 
              })(result0[0], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("can put lower octave dots or semicolons for lower-lower octave (. or :)");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_KOMMAL_INDICATOR() {
        var cacheKey = "KOMMAL_INDICATOR@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 95) {
          result0 = "_";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"_\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return { my_type: "kommal_indicator",
                                source:char,
                                }
                        })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("For the traditional bhatkande notation. for devanagri, indicates a flatted note, since devanagri seems not to have lowercase");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_LOWER_OCTAVE_LINE_ITEM() {
        var cacheKey = "LOWER_OCTAVE_LINE_ITEM@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        
        reportFailures++;
        result0 = parse_WHITE_SPACE();
        if (result0 === null) {
          result0 = parse_LOWER_OCTAVE_DOT();
          if (result0 === null) {
            result0 = parse_LOWER_LOWER_OCTAVE_SYMBOL();
            if (result0 === null) {
              result0 = parse_KOMMAL_INDICATOR();
            }
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed(".: for now");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_LOWER_OCTAVE_DOT() {
        var cacheKey = "LOWER_OCTAVE_DOT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (/^[.*]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[.*]");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return { my_type: "lower_octave_indicator",
                                source:char,
                                octave:-1
                                }
                     })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_UPPER_UPPER_OCTAVE_SYMBOL() {
        var cacheKey = "UPPER_UPPER_OCTAVE_SYMBOL@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 58) {
          result0 = ":";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\":\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return { my_type: "upper_upper_octave_indicator",
                                source:char,
                                octave:2
                                }
                     })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_LOWER_LOWER_OCTAVE_SYMBOL() {
        var cacheKey = "LOWER_LOWER_OCTAVE_SYMBOL@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 58) {
          result0 = ":";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\":\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return { my_type: "lower_lower_octave_indicator",
                                source:char,
                                octave:-2
                                }
                     })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_MORDENT() {
        var cacheKey = "MORDENT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 126) {
          result0 = "~";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"~\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return { my_type: "mordent",
                        source:char
                      }
             })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_TALA() {
        var cacheKey = "TALA@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (/^[+1203456]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[+1203456]");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return { my_type: "tala",
                        source:char
             }
                     })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("tala markings. ie +203 for tintal. 012 for rupak");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_END_SLUR() {
        var cacheKey = "END_SLUR@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 41) {
          result0 = ")";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\")\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return { my_type: "end_slur",
                                source:char
                                }
                     })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("symbol for end of a slur - a right paren");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_BEGIN_SLUR_OF_PITCH() {
        var cacheKey = "BEGIN_SLUR_OF_PITCH@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 40) {
          result0 = "(";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"(\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return { my_type: "begin_slur",
                                source:char
                                }
                     })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("symbol for beginning a slur - we use left-paren (");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_END_SLUR_OF_PITCH() {
        var cacheKey = "END_SLUR_OF_PITCH@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 41) {
          result0 = ")";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\")\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return { my_type: "end_slur",
                                source:char
                                }
                     })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("symbol for end of a slur - a right paren");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_UPPER_OCTAVE_DOT() {
        var cacheKey = "UPPER_OCTAVE_DOT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (/^[.*]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[.*]");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { 
                  return { my_type: "upper_octave_indicator",
                                source:char,
                                octave:1
                                }
                     })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_MEASURE() {
        var cacheKey = "ABC_MEASURE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_BARLINE();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result2 = parse_ABC_NON_BARLINE();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_ABC_NON_BARLINE();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_BARLINE();
            if (result2 === null) {
              pos2 = pos;
              reportFailures++;
              result2 = parse_LINE_END();
              reportFailures--;
              if (result2 !== null) {
                result2 = "";
                pos = pos2;
              } else {
                result2 = null;
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(start_obs, items, end_obs, _chunk) {
        
                  return parse_measure(start_obs,items,end_obs)
                     })(result0[0], result0[1], result0[2], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("measures,note that beginning and end of line implicitly demarcates a measure");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_MEASURE() {
        var cacheKey = "NUMBER_MEASURE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_BARLINE();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result2 = parse_NUMBER_NON_BARLINE();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_NUMBER_NON_BARLINE();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_BARLINE();
            if (result2 === null) {
              pos2 = pos;
              reportFailures++;
              result2 = parse_LINE_END();
              reportFailures--;
              if (result2 !== null) {
                result2 = "";
                pos = pos2;
              } else {
                result2 = null;
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(start_obs, items, end_obs, _chunk) {
                  return parse_measure(start_obs,items,end_obs)
                     })(result0[0], result0[1], result0[2], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("measures,note that beginning and end of line implicitly demarcates a measure");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_DEVANAGRI_MEASURE() {
        var cacheKey = "DEVANAGRI_MEASURE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_BARLINE();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result2 = parse_DEVANAGRI_NON_BARLINE();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_DEVANAGRI_NON_BARLINE();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_BARLINE();
            if (result2 === null) {
              pos2 = pos;
              reportFailures++;
              result2 = parse_LINE_END();
              reportFailures--;
              if (result2 !== null) {
                result2 = "";
                pos = pos2;
              } else {
                result2 = null;
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(start_obs, items, end_obs, _chunk) {
                  return parse_measure(start_obs,items,end_obs)
                     })(result0[0], result0[1], result0[2], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("measures,note that beginning and end of line implicitly demarcates a measure");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_MEASURE() {
        var cacheKey = "MEASURE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_BARLINE();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result2 = parse_NON_BARLINE();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_NON_BARLINE();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_BARLINE();
            if (result2 === null) {
              pos2 = pos;
              reportFailures++;
              result2 = parse_LINE_END();
              reportFailures--;
              if (result2 !== null) {
                result2 = "";
                pos = pos2;
              } else {
                result2 = null;
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(start_obs, items, end_obs, _chunk) {
                  return parse_measure(start_obs,items,end_obs)
                })(result0[0], result0[1], result0[2], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("measures,note that beginning and end of line implicitly demarcates a measure");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_NON_BARLINE() {
        var cacheKey = "ABC_NON_BARLINE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        result0 = parse_WHITE_SPACE();
        if (result0 === null) {
          result0 = parse_ABC_BEAT_DELIMITED();
          if (result0 === null) {
            result0 = parse_ABC_BEAT_UNDELIMITED();
            if (result0 === null) {
              result0 = parse_ABC_SARGAM_PITCH();
              if (result0 === null) {
                result0 = parse_RHYTHMICAL_DASH();
                if (result0 === null) {
                  pos0 = pos;
                  result0 = parse_REPEAT_SYMBOL();
                  _chunk.pos = pos0;
                  _chunk.end = pos;
                  _chunk.match = input.substring(pos0,pos);
                  if (result0 !== null) {
                    result0 = (function(x, _chunk) {
                              x.attributes=[];
                              return x;
                      })(result0, _chunk);
                  }
                  if (result0 === null) {
                    pos = pos0;
                  }
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_NON_BARLINE() {
        var cacheKey = "NUMBER_NON_BARLINE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        result0 = parse_WHITE_SPACE();
        if (result0 === null) {
          result0 = parse_NUMBER_BEAT_DELIMITED();
          if (result0 === null) {
            result0 = parse_NUMBER_BEAT_UNDELIMITED();
            if (result0 === null) {
              result0 = parse_NUMBER_SARGAM_PITCH();
              if (result0 === null) {
                result0 = parse_RHYTHMICAL_DASH();
                if (result0 === null) {
                  pos0 = pos;
                  result0 = parse_REPEAT_SYMBOL();
                  _chunk.pos = pos0;
                  _chunk.end = pos;
                  _chunk.match = input.substring(pos0,pos);
                  if (result0 !== null) {
                    result0 = (function(x, _chunk) {
                              x.attributes=[];
                              return x;
                      })(result0, _chunk);
                  }
                  if (result0 === null) {
                    pos = pos0;
                  }
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_DEVANAGRI_NON_BARLINE() {
        var cacheKey = "DEVANAGRI_NON_BARLINE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        result0 = parse_WHITE_SPACE();
        if (result0 === null) {
          result0 = parse_DEVANAGRI_BEAT_DELIMITED();
          if (result0 === null) {
            result0 = parse_DEVANAGRI_BEAT_UNDELIMITED();
            if (result0 === null) {
              result0 = parse_DEVANAGRI_SARGAM_PITCH();
              if (result0 === null) {
                result0 = parse_RHYTHMICAL_DASH();
                if (result0 === null) {
                  pos0 = pos;
                  result0 = parse_REPEAT_SYMBOL();
                  _chunk.pos = pos0;
                  _chunk.end = pos;
                  _chunk.match = input.substring(pos0,pos);
                  if (result0 !== null) {
                    result0 = (function(x, _chunk) {
                              x.attributes=[];
                              return x;
                      })(result0, _chunk);
                  }
                  if (result0 === null) {
                    pos = pos0;
                  }
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NON_BARLINE() {
        var cacheKey = "NON_BARLINE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        result0 = parse_WHITE_SPACE();
        if (result0 === null) {
          result0 = parse_BEAT_DELIMITED();
          if (result0 === null) {
            result0 = parse_BEAT_UNDELIMITED();
            if (result0 === null) {
              result0 = parse_SARGAM_PITCH();
              if (result0 === null) {
                result0 = parse_RHYTHMICAL_DASH();
                if (result0 === null) {
                  pos0 = pos;
                  result0 = parse_REPEAT_SYMBOL();
                  _chunk.pos = pos0;
                  _chunk.end = pos;
                  _chunk.match = input.substring(pos0,pos);
                  if (result0 !== null) {
                    result0 = (function(x, _chunk) {
                              x.attributes=[];
                              return x;
                      })(result0, _chunk);
                  }
                  if (result0 === null) {
                    pos = pos0;
                  }
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SARGAM_LINE_ITEM() {
        var cacheKey = "SARGAM_LINE_ITEM@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        result0 = parse_MEASURE();
        if (result0 === null) {
          result0 = parse_WHITE_SPACE();
          if (result0 === null) {
            result0 = parse_BEAT_DELIMITED();
            if (result0 === null) {
              result0 = parse_BEAT_UNDELIMITED();
              if (result0 === null) {
                result0 = parse_SARGAM_PITCH();
                if (result0 === null) {
                  result0 = parse_RHYTHMICAL_DASH();
                  if (result0 === null) {
                    result0 = parse_BARLINE();
                    if (result0 === null) {
                      pos0 = pos;
                      result0 = parse_REPEAT_SYMBOL();
                      _chunk.pos = pos0;
                      _chunk.end = pos;
                      _chunk.match = input.substring(pos0,pos);
                      if (result0 !== null) {
                        result0 = (function(x, _chunk) {
                                  x.attributes=[];
                                  return x;
                          })(result0, _chunk);
                      }
                      if (result0 === null) {
                        pos = pos0;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("an item in the main line");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_LINE_NUMBER() {
        var cacheKey = "LINE_NUMBER@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        if (/^[*0-9]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[*0-9]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[*0-9]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[*0-9]");
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 41) {
            result1 = ")";
            pos += 1;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\")\"");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(digits, ch, _chunk) {
                   source= digits.join('') + ")" 
                  return { my_type: "line_number",
                           source:source,
                         }
                     })(result0[0], result0[1], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie 1) 2) 3) etc");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_SARGAM_LINE() {
        var cacheKey = "ABC_SARGAM_LINE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_LINE_NUMBER();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result2 = parse_ABC_MEASURE();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_ABC_MEASURE();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_LINE_END();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(line_number, items, _chunk) {
               return parse_sargam_line(line_number,items,"ABC")
            })(result0[0], result0[1], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("consists of optional line# at beginning of line, followed by 1 or more measures followed by line end");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_DEVANAGRI_SARGAM_LINE() {
        var cacheKey = "DEVANAGRI_SARGAM_LINE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_LINE_NUMBER();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result2 = parse_DEVANAGRI_MEASURE();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_DEVANAGRI_MEASURE();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_LINE_END();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(line_number, items, _chunk) {
               return parse_sargam_line(line_number,items,"devanagri")
            })(result0[0], result0[1], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("consists of optional line# at beginning of line, followed by 1 or more measures followed by line end");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_SARGAM_LINE() {
        var cacheKey = "NUMBER_SARGAM_LINE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_LINE_NUMBER();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result2 = parse_NUMBER_MEASURE();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_NUMBER_MEASURE();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_LINE_END();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(line_number, items, _chunk) {
               return parse_sargam_line(line_number,items,"number")
            })(result0[0], result0[1], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("consists of optional line# at beginning of line, followed by 1 or more measures followed by line end");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SARGAM_LINE() {
        var cacheKey = "SARGAM_LINE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_LINE_NUMBER();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result2 = parse_MEASURE();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_MEASURE();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_LINE_END();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(line_number, items, _chunk) {
               return parse_sargam_line(line_number,items,"latin_sargam")
              })(result0[0], result0[1], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("consists of optional line# at beginning of line, followed by 1 or more measures followed by line end");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_BEAT_UNDELIMITED() {
        var cacheKey = "NUMBER_BEAT_UNDELIMITED@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        result1 = parse_NUMBER_BEAT_UNDELIMITED_ITEM();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_NUMBER_BEAT_UNDELIMITED_ITEM();
          }
        } else {
          result0 = null;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(beat_items, _chunk) { 
                    return parse_beat_undelimited(beat_items)
                 })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("beats can be indicated by a group of pitches that consist only of pitches and dashes such as S--R--G-");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_BEAT_UNDELIMITED() {
        var cacheKey = "ABC_BEAT_UNDELIMITED@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        result1 = parse_ABC_BEAT_UNDELIMITED_ITEM();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_ABC_BEAT_UNDELIMITED_ITEM();
          }
        } else {
          result0 = null;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(beat_items, _chunk) { 
                    return parse_beat_undelimited(beat_items)
                 })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("beats can be indicated by a group of pitches that consist only of pitches and dashes such as S--R--G-");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_BEAT_UNDELIMITED() {
        var cacheKey = "BEAT_UNDELIMITED@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        result1 = parse_BEAT_UNDELIMITED_ITEM();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_BEAT_UNDELIMITED_ITEM();
          }
        } else {
          result0 = null;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(beat_items, _chunk) { 
                    return parse_beat_undelimited(beat_items)
                 })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("beats can be indicated by a group of pitches that consist only of pitches and dashes such as S--R--G-");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_DEVANAGRI_BEAT_UNDELIMITED() {
        var cacheKey = "DEVANAGRI_BEAT_UNDELIMITED@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        result1 = parse_DEVANAGRI_BEAT_UNDELIMITED_ITEM();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_DEVANAGRI_BEAT_UNDELIMITED_ITEM();
          }
        } else {
          result0 = null;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(beat_items, _chunk) { 
              return parse_beat_undelimited(beat_items)
            })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("beats can be indicated by a group of pitches that consist only of pitches and dashes such as S--R--G-");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_BEAT_UNDELIMITED_ITEM() {
        var cacheKey = "NUMBER_BEAT_UNDELIMITED_ITEM@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        
        reportFailures++;
        result0 = parse_NUMBER_SARGAM_PITCH();
        if (result0 === null) {
          result0 = parse_RHYTHMICAL_DASH();
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("1--2--3-");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_BEAT_UNDELIMITED_ITEM() {
        var cacheKey = "ABC_BEAT_UNDELIMITED_ITEM@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        
        reportFailures++;
        result0 = parse_ABC_SARGAM_PITCH();
        if (result0 === null) {
          result0 = parse_RHYTHMICAL_DASH();
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("C--D--E-");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_DEVANAGRI_BEAT_UNDELIMITED_ITEM() {
        var cacheKey = "DEVANAGRI_BEAT_UNDELIMITED_ITEM@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        
        reportFailures++;
        result0 = parse_DEVANAGRI_SARGAM_PITCH();
        if (result0 === null) {
          result0 = parse_RHYTHMICAL_DASH();
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("inside of a simple beat, ie S--R--G-");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_UNDELIMITED_SARGAM_PITCH_WITH_DASHES() {
        var cacheKey = "UNDELIMITED_SARGAM_PITCH_WITH_DASHES@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SARGAM_PITCH();
        if (result0 !== null) {
          result2 = parse_RHYTHMICAL_DASH();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_RHYTHMICAL_DASH();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(pitch, dashes, _chunk) {
                 pitch.numerator=dashes.length+1
                 return([pitch].concat(dashes))
              })(result0[0], result0[1], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("for example S--");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_BEAT_UNDELIMITED_ITEM() {
        var cacheKey = "BEAT_UNDELIMITED_ITEM@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        
        reportFailures++;
        result0 = parse_UNDELIMITED_SARGAM_PITCH_WITH_DASHES();
        if (result0 === null) {
          result0 = parse_SARGAM_PITCH();
          if (result0 === null) {
            result0 = parse_RHYTHMICAL_DASH();
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("inside of a simple beat, ie S--R--G- Note that undelimited beats cannot contain spaces");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_BEAT_DELIMITED() {
        var cacheKey = "ABC_BEAT_DELIMITED@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_BEGIN_BEAT_SYMBOL();
        if (result0 !== null) {
          result2 = parse_ABC_BEAT_DELIMITED_ITEM();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_ABC_BEAT_DELIMITED_ITEM();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_END_BEAT_SYMBOL();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(begin_symbol, beat_items, end_symbol, _chunk) { 
                  return parse_beat_delimited(begin_symbol,beat_items,end_symbol)
                 })(result0[0], result0[1], result0[2], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie <C D E F> .");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_BEAT_DELIMITED() {
        var cacheKey = "NUMBER_BEAT_DELIMITED@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_BEGIN_BEAT_SYMBOL();
        if (result0 !== null) {
          result2 = parse_NUMBER_BEAT_DELIMITED_ITEM();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_NUMBER_BEAT_DELIMITED_ITEM();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_END_BEAT_SYMBOL();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(begin_symbol, beat_items, end_symbol, _chunk) { 
                  return parse_beat_delimited(begin_symbol,beat_items,end_symbol)
                 })(result0[0], result0[1], result0[2], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie <1 2 3> . Useful if lyrics wouldn't line up otherwise!. use <Srgm> or <S r g m> to group pithes into a single beat. The <> delimiters correspond to the lower loop in the aacm notation system");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_DEVANAGRI_BEAT_DELIMITED() {
        var cacheKey = "DEVANAGRI_BEAT_DELIMITED@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_BEGIN_BEAT_SYMBOL();
        if (result0 !== null) {
          result2 = parse_DEVANAGRI_BEAT_DELIMITED_ITEM();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_DEVANAGRI_BEAT_DELIMITED_ITEM();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_END_BEAT_SYMBOL();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(begin_symbol, beat_items, end_symbol, _chunk) { 
                  return parse_beat_delimited(begin_symbol,beat_items,end_symbol)
                 })(result0[0], result0[1], result0[2], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie <S R G m> . Useful if lyrics wouldn't line up otherwise!. use <Srgm> or <S r g m> to group pithes into a single beat. The <> delimiters correspond to the lower loop in the aacm notation system");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_BEAT_DELIMITED() {
        var cacheKey = "BEAT_DELIMITED@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_BEGIN_BEAT_SYMBOL();
        if (result0 !== null) {
          result2 = parse_BEAT_DELIMITED_ITEM();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_BEAT_DELIMITED_ITEM();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_END_BEAT_SYMBOL();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(begin_symbol, beat_items, end_symbol, _chunk) { 
                  return parse_beat_delimited(begin_symbol,beat_items,end_symbol)
                 })(result0[0], result0[1], result0[2], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie <S R G m> . Useful if lyrics wouldn't line up otherwise!. use <Srgm> or <S r g m> to group pithes into a single beat. The <> delimiters correspond to the lower loop in the aacm notation system");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_BEGIN_BEAT_SYMBOL() {
        var cacheKey = "BEGIN_BEAT_SYMBOL@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 60) {
          result0 = "<";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"<\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return {
                                 my_type: "begin_beat",
                                 source: char
                              }
                     })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("symbol to use to indicate start of beat");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_END_BEAT_SYMBOL() {
        var cacheKey = "END_BEAT_SYMBOL@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 62) {
          result0 = ">";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\">\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return {
                                 my_type: "end_beat",
                                 source: char
                              }
                     })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("Symbol to use to indicate end of beat");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_BEAT_DELIMITED_ITEM() {
        var cacheKey = "ABC_BEAT_DELIMITED_ITEM@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        
        reportFailures++;
        result0 = parse_ABC_SARGAM_PITCH();
        if (result0 === null) {
          result0 = parse_RHYTHMICAL_DASH();
          if (result0 === null) {
            result0 = parse_WHITE_SPACE();
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("inside of a delimited beat, ie C--D--E-");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_BEAT_DELIMITED_ITEM() {
        var cacheKey = "NUMBER_BEAT_DELIMITED_ITEM@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        
        reportFailures++;
        result0 = parse_NUMBER_SARGAM_PITCH();
        if (result0 === null) {
          result0 = parse_RHYTHMICAL_DASH();
          if (result0 === null) {
            result0 = parse_WHITE_SPACE();
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("inside of a delimited beat, ie 1--3--2-");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_DEVANAGRI_BEAT_DELIMITED_ITEM() {
        var cacheKey = "DEVANAGRI_BEAT_DELIMITED_ITEM@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        
        reportFailures++;
        result0 = parse_DEVANAGRI_SARGAM_PITCH();
        if (result0 === null) {
          result0 = parse_RHYTHMICAL_DASH();
          if (result0 === null) {
            result0 = parse_WHITE_SPACE();
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("inside of a delimited beat, ie S--R--G-");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_BEAT_DELIMITED_ITEM() {
        var cacheKey = "BEAT_DELIMITED_ITEM@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        
        reportFailures++;
        result0 = parse_SARGAM_PITCH();
        if (result0 === null) {
          result0 = parse_RHYTHMICAL_DASH();
          if (result0 === null) {
            result0 = parse_WHITE_SPACE();
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("inside of a delimited beat, ie S--R--G-");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_WORD() {
        var cacheKey = "WORD@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        if (/^[a-zA-Z]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[a-zA-Z]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[a-zA-Z]");
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = parse_WHITE_SPACE();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(letters, _chunk) { return { my_type: "word",
                                                          word: letters.join("")
                                                         }
                                             })(result0[0], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("a non-syllable like john");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse__() {
        var cacheKey = "_@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        result0 = [];
        result1 = parse_SPACE();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_SPACE();
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(blanks, _chunk) { if (blanks.length==0) {
                                return '' 
                             }
                             return { my_type:"whitespace",
                                     source: blanks.join('')
                                     }
                                     })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("whitespace");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SYLLABLE() {
        var cacheKey = "SYLLABLE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        if (/^[a-zA-Z'!]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z'!]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[a-zA-Z'!]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[a-zA-Z'!]");
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 45) {
            result1 = "-";
            pos += 1;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse__();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(letters, optional_dash, whitespace, _chunk) { var syl = letters.join('') + optional_dash
               return _.compact([{ my_type:  "syllable",
                        syllable: syl,
                        source: syl 
                      }, whitespace])
                      })(result0[0], result0[1], result0[2], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("for example he- or world");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_LYRICS_LINE() {
        var cacheKey = "LYRICS_LINE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_WHITE_SPACE();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result2 = parse_SYLLABLE();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_SYLLABLE();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_WHITE_SPACE();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_LINE_END();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(begin_white_space, items, end_white_space, _chunk) {  
                 my_items =  _.compact(_.flatten([begin_white_space, items,end_white_space]))
                 return {
                   my_type:"lyrics_line",
                   items:my_items,
                   source: this.get_source_for_items(my_items),
                      }
              })(result0[0], result0[1], result0[2], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("line of syllables");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_RHYTHMICAL_DASH() {
        var cacheKey = "RHYTHMICAL_DASH@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 45) {
          result0 = "-";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"-\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(source, _chunk) { 
                         return { my_type: "dash",
                           source: "-"
                              }
                        })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie a -, used as a rhythmical placeholder. IE S--R--G- ");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_DEVANAGRI_SA() {
        var cacheKey = "DEVANAGRI_SA@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 2360) {
          result0 = "\u0938";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\u0938\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"C")
             })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("sa in devanagri");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_DEVANAGRI_RE() {
        var cacheKey = "DEVANAGRI_RE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 2352) {
          result0 = "\u0930";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\u0930\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"D") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("re in devanagri");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_DEVANAGRI_GA() {
        var cacheKey = "DEVANAGRI_GA@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 2394) {
          result0 = "\u095A";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\u095A\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"E") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ga in devanagri");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_DEVANAGRI_MA_SHARP() {
        var cacheKey = "DEVANAGRI_MA_SHARP@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.substr(pos, 2) === "\u092E'") {
          result0 = "\u092E'";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\u092E'\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"F#") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("tivra ma in devanagri. NOTE THE TICK!!!!");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_DEVANAGRI_MA() {
        var cacheKey = "DEVANAGRI_MA@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 2350) {
          result0 = "\u092E";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\u092E\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"F") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ma in devanagri");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_DEVANAGRI_PA() {
        var cacheKey = "DEVANAGRI_PA@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 2346) {
          result0 = "\u092A";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\u092A\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"G") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("pa in devanagri");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_DEVANAGRI_DHA() {
        var cacheKey = "DEVANAGRI_DHA@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 2343) {
          result0 = "\u0927";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\u0927\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"A") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("dha in devanagri");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_DEVANAGRI_NI() {
        var cacheKey = "DEVANAGRI_NI@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 2345) {
          result0 = "\u0929";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\u0929\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"B") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ni in devanagri");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_MUSICAL_CHAR() {
        var cacheKey = "ABC_MUSICAL_CHAR@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        
        result0 = parse_ABC_CSHARP();
        if (result0 === null) {
          result0 = parse_ABC_CFLAT();
          if (result0 === null) {
            result0 = parse_ABC_DFLAT();
            if (result0 === null) {
              result0 = parse_ABC_DSHARP();
              if (result0 === null) {
                result0 = parse_ABC_EFLAT();
                if (result0 === null) {
                  result0 = parse_ABC_FSHARP();
                  if (result0 === null) {
                    result0 = parse_ABC_GFLAT();
                    if (result0 === null) {
                      result0 = parse_ABC_GSHARP();
                      if (result0 === null) {
                        result0 = parse_ABC_AFLAT();
                        if (result0 === null) {
                          result0 = parse_ABC_ASHARP();
                          if (result0 === null) {
                            result0 = parse_ABC_BFLAT();
                            if (result0 === null) {
                              result0 = parse_ABC_BSHARP();
                              if (result0 === null) {
                                result0 = parse_ABC_C();
                                if (result0 === null) {
                                  result0 = parse_ABC_D();
                                  if (result0 === null) {
                                    result0 = parse_ABC_E();
                                    if (result0 === null) {
                                      result0 = parse_ABC_F();
                                      if (result0 === null) {
                                        result0 = parse_ABC_G();
                                        if (result0 === null) {
                                          result0 = parse_ABC_A();
                                          if (result0 === null) {
                                            result0 = parse_ABC_B();
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_C() {
        var cacheKey = "ABC_C@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 67) {
          result0 = "C";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"C\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"C") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_D() {
        var cacheKey = "ABC_D@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 68) {
          result0 = "D";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"D\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"D") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_E() {
        var cacheKey = "ABC_E@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 69) {
          result0 = "E";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"E\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"E") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_F() {
        var cacheKey = "ABC_F@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 70) {
          result0 = "F";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"F\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"F") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_G() {
        var cacheKey = "ABC_G@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 71) {
          result0 = "G";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"G\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"G") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_A() {
        var cacheKey = "ABC_A@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 65) {
          result0 = "A";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"A\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"A") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_B() {
        var cacheKey = "ABC_B@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 66) {
          result0 = "B";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"B\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"B") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_CSHARP() {
        var cacheKey = "ABC_CSHARP@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "C#") {
          result0 = "C#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"C#\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"C#") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_CFLAT() {
        var cacheKey = "ABC_CFLAT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "Cb") {
          result0 = "Cb";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"Cb\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"Cb") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_DFLAT() {
        var cacheKey = "ABC_DFLAT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "Db") {
          result0 = "Db";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"Db\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"Db") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_DSHARP() {
        var cacheKey = "ABC_DSHARP@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "D#") {
          result0 = "D#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"D#\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"D#") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_EFLAT() {
        var cacheKey = "ABC_EFLAT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "Eb") {
          result0 = "Eb";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"Eb\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"Eb") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_FSHARP() {
        var cacheKey = "ABC_FSHARP@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "F#") {
          result0 = "F#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"F#\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"F#") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_GFLAT() {
        var cacheKey = "ABC_GFLAT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "Gb") {
          result0 = "Gb";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"Gb\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"Gb") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_GSHARP() {
        var cacheKey = "ABC_GSHARP@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "G#") {
          result0 = "G#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"G#\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"G#") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_AFLAT() {
        var cacheKey = "ABC_AFLAT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "Ab") {
          result0 = "Ab";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"Ab\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"Ab") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_ASHARP() {
        var cacheKey = "ABC_ASHARP@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "A#") {
          result0 = "A#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"A#\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"A#") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_BFLAT() {
        var cacheKey = "ABC_BFLAT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "Bb") {
          result0 = "Bb";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"Bb\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"Bb") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_BSHARP() {
        var cacheKey = "ABC_BSHARP@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "B#") {
          result0 = "B#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"B#\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"B#") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_MUSICAL_CHAR() {
        var cacheKey = "NUMBER_MUSICAL_CHAR@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        
        result0 = parse_NUMBER_CSHARP();
        if (result0 === null) {
          result0 = parse_NUMBER_CFLAT();
          if (result0 === null) {
            result0 = parse_NUMBER_DFLAT();
            if (result0 === null) {
              result0 = parse_NUMBER_DSHARP();
              if (result0 === null) {
                result0 = parse_NUMBER_EFLAT();
                if (result0 === null) {
                  result0 = parse_NUMBER_ESHARP();
                  if (result0 === null) {
                    result0 = parse_NUMBER_FFLAT();
                    if (result0 === null) {
                      result0 = parse_NUMBER_FSHARP();
                      if (result0 === null) {
                        result0 = parse_NUMBER_GFLAT();
                        if (result0 === null) {
                          result0 = parse_NUMBER_GSHARP();
                          if (result0 === null) {
                            result0 = parse_NUMBER_AFLAT();
                            if (result0 === null) {
                              result0 = parse_NUMBER_ASHARP();
                              if (result0 === null) {
                                result0 = parse_NUMBER_BFLAT();
                                if (result0 === null) {
                                  result0 = parse_NUMBER_BSHARP();
                                  if (result0 === null) {
                                    result0 = parse_NUMBER_C();
                                    if (result0 === null) {
                                      result0 = parse_NUMBER_D();
                                      if (result0 === null) {
                                        result0 = parse_NUMBER_E();
                                        if (result0 === null) {
                                          result0 = parse_NUMBER_F();
                                          if (result0 === null) {
                                            result0 = parse_NUMBER_G();
                                            if (result0 === null) {
                                              result0 = parse_NUMBER_A();
                                              if (result0 === null) {
                                                result0 = parse_NUMBER_B();
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_C() {
        var cacheKey = "NUMBER_C@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 49) {
          result0 = "1";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"1\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"C") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_D() {
        var cacheKey = "NUMBER_D@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 50) {
          result0 = "2";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"2\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"D") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_E() {
        var cacheKey = "NUMBER_E@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 51) {
          result0 = "3";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"3\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"E") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_F() {
        var cacheKey = "NUMBER_F@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 52) {
          result0 = "4";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"4\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"F") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_G() {
        var cacheKey = "NUMBER_G@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 53) {
          result0 = "5";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"5\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"G") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_A() {
        var cacheKey = "NUMBER_A@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 54) {
          result0 = "6";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"6\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"A") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_B() {
        var cacheKey = "NUMBER_B@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 55) {
          result0 = "7";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"7\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"B") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_CSHARP() {
        var cacheKey = "NUMBER_CSHARP@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "1#") {
          result0 = "1#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"1#\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"C#") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_CFLAT() {
        var cacheKey = "NUMBER_CFLAT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "1b") {
          result0 = "1b";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"1b\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"Cb") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_DFLAT() {
        var cacheKey = "NUMBER_DFLAT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "2b") {
          result0 = "2b";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"2b\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"Db") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_DSHARP() {
        var cacheKey = "NUMBER_DSHARP@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "2#") {
          result0 = "2#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"2#\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"D#") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_EFLAT() {
        var cacheKey = "NUMBER_EFLAT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "3b") {
          result0 = "3b";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"3b\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"Eb") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_ESHARP() {
        var cacheKey = "NUMBER_ESHARP@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "3#") {
          result0 = "3#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"3#\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"E#") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_FFLAT() {
        var cacheKey = "NUMBER_FFLAT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "4b") {
          result0 = "4b";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"4b\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"Fb") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_FSHARP() {
        var cacheKey = "NUMBER_FSHARP@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "4#") {
          result0 = "4#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"4#\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"F#") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_GFLAT() {
        var cacheKey = "NUMBER_GFLAT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "5b") {
          result0 = "5b";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"5b\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"Gb") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_GSHARP() {
        var cacheKey = "NUMBER_GSHARP@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "5#") {
          result0 = "5#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"5#\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"G#") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_AFLAT() {
        var cacheKey = "NUMBER_AFLAT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "6b") {
          result0 = "6b";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"6b\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"Ab") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_ASHARP() {
        var cacheKey = "NUMBER_ASHARP@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "6#") {
          result0 = "6#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"6#\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"A#") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_BFLAT() {
        var cacheKey = "NUMBER_BFLAT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "7b") {
          result0 = "7b";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"7b\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"Bb") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_BSHARP() {
        var cacheKey = "NUMBER_BSHARP@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "7#") {
          result0 = "7#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"7#\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) { return sa_helper(char,"B#") })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_DEVANAGRI_MUSICAL_CHAR() {
        var cacheKey = "DEVANAGRI_MUSICAL_CHAR@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        
        reportFailures++;
        result0 = parse_DEVANAGRI_SA();
        if (result0 === null) {
          result0 = parse_DEVANAGRI_RE();
          if (result0 === null) {
            result0 = parse_DEVANAGRI_GA();
            if (result0 === null) {
              result0 = parse_DEVANAGRI_MA_SHARP();
              if (result0 === null) {
                result0 = parse_DEVANAGRI_MA();
                if (result0 === null) {
                  result0 = parse_DEVANAGRI_PA();
                  if (result0 === null) {
                    result0 = parse_DEVANAGRI_DHA();
                    if (result0 === null) {
                      result0 = parse_DEVANAGRI_NI();
                    }
                  }
                }
              }
            }
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("devanagri characters.");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SARGAM_MUSICAL_CHAR() {
        var cacheKey = "SARGAM_MUSICAL_CHAR@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1;
        var pos0;
        
        reportFailures++;
        result0 = parse_SARGAM_SA_FLAT();
        if (result0 === null) {
          result0 = parse_SARGAM_SA_SHARP();
          if (result0 === null) {
            result0 = parse_SARGAM_RE_SHARP();
            if (result0 === null) {
              result0 = parse_SARGAM_GA_SHARP();
              if (result0 === null) {
                result0 = parse_SARGAM_PA_SHARP();
                if (result0 === null) {
                  result0 = parse_SARGAM_PA_FLAT();
                  if (result0 === null) {
                    result0 = parse_SARGAM_DHA_SHARP();
                    if (result0 === null) {
                      pos0 = pos;
                      result0 = parse_SARGAM_NI_SHARP();
                      if (result0 !== null) {
                        result1 = parse_SARGAM_PA_FLAT();
                        if (result1 !== null) {
                          result0 = [result0, result1];
                        } else {
                          result0 = null;
                          pos = pos0;
                        }
                      } else {
                        result0 = null;
                        pos = pos0;
                      }
                      if (result0 === null) {
                        result0 = parse_SARGAM_SA();
                        if (result0 === null) {
                          result0 = parse_SARGAM_RE_FLAT();
                          if (result0 === null) {
                            result0 = parse_SARGAM_RE();
                            if (result0 === null) {
                              result0 = parse_SARGAM_GA_FLAT();
                              if (result0 === null) {
                                result0 = parse_SARGAM_GA();
                                if (result0 === null) {
                                  result0 = parse_SARGAM_MA();
                                  if (result0 === null) {
                                    result0 = parse_SARGAM_MA_SHARP();
                                    if (result0 === null) {
                                      result0 = parse_SARGAM_PA();
                                      if (result0 === null) {
                                        result0 = parse_SARGAM_DHA_FLAT();
                                        if (result0 === null) {
                                          result0 = parse_SARGAM_DHA();
                                          if (result0 === null) {
                                            result0 = parse_SARGAM_NI_FLAT();
                                            if (result0 === null) {
                                              result0 = parse_SARGAM_NI();
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("Letters SrRgGmMPdDnN in latin script");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_SARGAM_CHAR() {
        var cacheKey = "ABC_SARGAM_CHAR@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (/^[CDEFGAB]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[CDEFGAB]");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) {
                 return char;
         })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie SrRgG, and possibly the devanagri characters as well");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SARGAM_SA() {
        var cacheKey = "SARGAM_SA@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 83) {
          result0 = "S";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"S\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) {return sa_helper(char,"C")})(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SARGAM_SA_FLAT() {
        var cacheKey = "SARGAM_SA_FLAT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "Sb") {
          result0 = "Sb";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"Sb\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) {return sa_helper(char,"Cb")})(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SARGAM_SA_SHARP() {
        var cacheKey = "SARGAM_SA_SHARP@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "S#") {
          result0 = "S#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"S#\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) {return sa_helper(char,"C#")})(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SARGAM_RE_FLAT() {
        var cacheKey = "SARGAM_RE_FLAT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 114) {
          result0 = "r";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"r\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) {return sa_helper(char,"Db")})(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SARGAM_RE() {
        var cacheKey = "SARGAM_RE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 82) {
          result0 = "R";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"R\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) {return sa_helper(char,"D")})(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SARGAM_RE_SHARP() {
        var cacheKey = "SARGAM_RE_SHARP@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "R#") {
          result0 = "R#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"R#\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) {return sa_helper(char,"D#")})(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SARGAM_GA_SHARP() {
        var cacheKey = "SARGAM_GA_SHARP@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "G#") {
          result0 = "G#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"G#\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) {return sa_helper(char,"E#")})(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SARGAM_GA_FLAT() {
        var cacheKey = "SARGAM_GA_FLAT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 103) {
          result0 = "g";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"g\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) {return sa_helper(char,"Eb")})(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SARGAM_GA() {
        var cacheKey = "SARGAM_GA@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 71) {
          result0 = "G";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"G\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) {return sa_helper(char,"E")})(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SARGAM_MA() {
        var cacheKey = "SARGAM_MA@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 109) {
          result0 = "m";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"m\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) {return sa_helper(char,"F")})(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SARGAM_MA_SHARP() {
        var cacheKey = "SARGAM_MA_SHARP@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 77) {
          result0 = "M";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"M\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) {return sa_helper(char,"F#")})(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SARGAM_PA() {
        var cacheKey = "SARGAM_PA@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 80) {
          result0 = "P";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"P\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) {return sa_helper(char,"G")})(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SARGAM_PA_FLAT() {
        var cacheKey = "SARGAM_PA_FLAT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "Pb") {
          result0 = "Pb";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"Pb\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) {return sa_helper(char,"Gb")})(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SARGAM_PA_SHARP() {
        var cacheKey = "SARGAM_PA_SHARP@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "P#") {
          result0 = "P#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"P#\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) {return sa_helper(char,"G#")})(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SARGAM_DHA_FLAT() {
        var cacheKey = "SARGAM_DHA_FLAT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 100) {
          result0 = "d";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"d\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) {return sa_helper(char,"Ab")})(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SARGAM_DHA() {
        var cacheKey = "SARGAM_DHA@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 68) {
          result0 = "D";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"D\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) {return sa_helper(char,"A")})(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SARGAM_DHA_SHARP() {
        var cacheKey = "SARGAM_DHA_SHARP@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "D#") {
          result0 = "D#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"D#\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) {return sa_helper(char,"A#")})(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SARGAM_NI_FLAT() {
        var cacheKey = "SARGAM_NI_FLAT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 110) {
          result0 = "n";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"n\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) {return sa_helper(char,"Bb")})(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SARGAM_NI() {
        var cacheKey = "SARGAM_NI@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 78) {
          result0 = "N";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"N\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) {return sa_helper(char,"B")})(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SARGAM_NI_SHARP() {
        var cacheKey = "SARGAM_NI_SHARP@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "N#") {
          result0 = "N#";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"N#\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(char, _chunk) {return sa_helper(char,"B#")})(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_NUMBER_SARGAM_PITCH() {
        var cacheKey = "NUMBER_SARGAM_PITCH@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_BEGIN_SLUR_OF_PITCH();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_NUMBER_MUSICAL_CHAR();
          if (result1 !== null) {
            result2 = parse_END_SLUR_OF_PITCH();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(slur, char, end_slur, _chunk) { 
                  return parse_sargam_pitch(slur,char,end_slur)
               })(result0[0], result0[1], result0[2], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie 123");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_ABC_SARGAM_PITCH() {
        var cacheKey = "ABC_SARGAM_PITCH@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_BEGIN_SLUR_OF_PITCH();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_ABC_MUSICAL_CHAR();
          if (result1 !== null) {
            result2 = parse_END_SLUR_OF_PITCH();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(slur, char, end_slur, _chunk) { 
                  return parse_sargam_pitch(slur,char,end_slur)
               })(result0[0], result0[1], result0[2], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie CDE");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_DEVANAGRI_SARGAM_PITCH() {
        var cacheKey = "DEVANAGRI_SARGAM_PITCH@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_BEGIN_SLUR_OF_PITCH();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_DEVANAGRI_MUSICAL_CHAR();
          if (result1 !== null) {
            result2 = parse_END_SLUR_OF_PITCH();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(slur, char, end_slur, _chunk) { 
                  return parse_sargam_pitch(slur,char,end_slur)
               })(result0[0], result0[1], result0[2], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("a sargam pitch ie SrR..");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SARGAM_PITCH() {
        var cacheKey = "SARGAM_PITCH@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_BEGIN_SLUR_OF_PITCH();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_SARGAM_MUSICAL_CHAR();
          if (result1 !== null) {
            result2 = parse_END_SLUR_OF_PITCH();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(slur, char, end_slur, _chunk) { 
                  return parse_sargam_pitch(slur,char,end_slur)
               })(result0[0], result0[1], result0[2], _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("a sargam pitch ie SrR..");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_REPEAT_SYMBOL() {
        var cacheKey = "REPEAT_SYMBOL@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 37) {
          result0 = "%";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"%\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(str, _chunk) { return { my_type:"repeat_symbol",
                             source: str,
                              }
                      })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie %");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_BARLINE() {
        var cacheKey = "BARLINE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        result0 = parse_REVERSE_FINAL_BARLINE();
        if (result0 === null) {
          result0 = parse_FINAL_BARLINE();
          if (result0 === null) {
            result0 = parse_DOUBLE_BARLINE();
            if (result0 === null) {
              result0 = parse_LEFT_REPEAT();
              if (result0 === null) {
                result0 = parse_RIGHT_REPEAT();
                if (result0 === null) {
                  pos0 = pos;
                  result0 = parse_SINGLE_BARLINE();
                  _chunk.pos = pos0;
                  _chunk.end = pos;
                  _chunk.match = input.substring(pos0,pos);
                  if (result0 !== null) {
                    result0 = (function(barline, _chunk) { return barline})(result0, _chunk);
                  }
                  if (result0 === null) {
                    pos = pos0;
                  }
                }
              }
            }
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("a musical barline or repeat");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_REVERSE_FINAL_BARLINE() {
        var cacheKey = "REVERSE_FINAL_BARLINE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.substr(pos, 2) === "[|") {
          result0 = "[|";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[|\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(str, _chunk) { return { my_type:"reverse_final_barline",
                          source: str,
                         is_barline:true
                        }
                      })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie [|, a reverse final barline");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_FINAL_BARLINE() {
        var cacheKey = "FINAL_BARLINE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.substr(pos, 2) === "|]") {
          result0 = "|]";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"|]\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(str, _chunk) { return { my_type:"final_barline",
                            source: str,
                            is_barline:true
                          }
                      })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie ||, a final barline");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_DOUBLE_BARLINE() {
        var cacheKey = "DOUBLE_BARLINE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.substr(pos, 2) === "||") {
          result0 = "||";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"||\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(str, _chunk) { return { my_type:"double_barline",
                             source: str,
                            is_barline:true
                              }
                      })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie ||, a solid barline");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SINGLE_BARLINE() {
        var cacheKey = "SINGLE_BARLINE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.charCodeAt(pos) === 124) {
          result0 = "|";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"|\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(str, _chunk) { return { my_type: "single_barline",
                           is_barline:true,
                          source: str
                           }
                })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie |");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_LEFT_REPEAT() {
        var cacheKey = "LEFT_REPEAT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.substr(pos, 2) === "|:") {
          result0 = "|:";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"|:\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(_chunk) { return { my_type: "left_repeat",
                           is_barline:true,
                          source: "|:"
                           }
                })(_chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie |:");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_RIGHT_REPEAT() {
        var cacheKey = "RIGHT_REPEAT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        if (input.substr(pos, 2) === ":|") {
          result0 = ":|";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\":|\"");
          }
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(_chunk) { return { my_type: "right_repeat",
                             is_barline:true,
                             source: ":|"
                           }
                })(_chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("ie :|");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_LINE_END_CHAR() {
        var cacheKey = "LINE_END_CHAR@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        
        if (input.substr(pos, 2) === "\r\n") {
          result0 = "\r\n";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\r\\n\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 13) {
            result0 = "\r";
            pos += 1;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\r\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 10) {
              result0 = "\n";
              pos += 1;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\n\"");
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_EOL() {
        var cacheKey = "EOL@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        result0 = parse_LINE_END_CHAR();
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(_chunk) { return { my_type: "end_of_line",
                            source: "\n"
                            }})(_chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("end of line");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_EOF() {
        var cacheKey = "EOF@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        reportFailures++;
        if (input.length > pos) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("any character");
          }
        }
        reportFailures--;
        if (result0 === null) {
          result0 = "";
        } else {
          result0 = null;
          pos = pos1;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(_chunk) { return { my_type: "end_of_file",
                          source: "" }})(_chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("end of file");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_SPACE() {
        var cacheKey = "SPACE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0;
        
        reportFailures++;
        if (input.charCodeAt(pos) === 32) {
          result0 = " ";
          pos += 1;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\" \"");
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("space or tab char");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function parse_WHITE_SPACE() {
        var cacheKey = "WHITE_SPACE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var result0, result1;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        result1 = parse_SPACE();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_SPACE();
          }
        } else {
          result0 = null;
        }
        _chunk.pos = pos0;
        _chunk.end = pos;
        _chunk.match = input.substring(pos0,pos);
        if (result0 !== null) {
          result0 = (function(spaces, _chunk) { return { my_type: "whitespace",
                             source: spaces.join("")
                             }
                             })(result0, _chunk);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("white space");
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  result0
        };
        return result0;
      }
      
      function buildErrorMessage() {
        function buildExpected(failuresExpected) {
          failuresExpected.sort();
          
          var lastFailure = null;
          var failuresExpectedUnique = [];
          for (var i = 0; i < failuresExpected.length; i++) {
            if (failuresExpected[i] !== lastFailure) {
              failuresExpectedUnique.push(failuresExpected[i]);
              lastFailure = failuresExpected[i];
            }
          }
          
          switch (failuresExpectedUnique.length) {
            case 0:
              return "end of input";
            case 1:
              return failuresExpectedUnique[0];
            default:
              return failuresExpectedUnique.slice(0, failuresExpectedUnique.length - 1).join(", ")
                + " or "
                + failuresExpectedUnique[failuresExpectedUnique.length - 1];
          }
        }
        
        var expected = buildExpected(rightmostFailuresExpected);
        var actualPos = Math.max(pos, rightmostFailuresPos);
        var actual = actualPos < input.length
          ? quote(input.charAt(actualPos))
          : "end of input";
        
        return "Expected " + expected + " but " + actual + " found.";
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
        /* Initializer. All the functions in this block are available */
        debug=false
        if (typeof module !== 'undefined' && module.exports) {
          // running under node.js
          zz = require('./shims.js');
          util = require('util');
          _ = require("underscore")._;
          shared=require('./shared.js')
          _.extend(root,shared)
          get_composition_attribute=shared.get_composition_attribute
          ParserHelper= require("./parser_helper.js").ParserHelper
          Fraction=require('./third_party/fraction.js').Fraction
        }
        Helper =ParserHelper
        // Mix in the methods from Helper.
        // TODO: find a more elegant way to do this.
        // didn't work. _.extend(this, Helper) 
        //
        id_ctr=1
        sa_helper=Helper.sa_helper
        parse_line=Helper.parse_line
        handle_ornament=Helper.handle_ornament
        find_ornaments=Helper.find_ornaments
        running_under_node=Helper.running_under_node
        map_ornaments=Helper.map_ornaments
        parse_ornament=Helper.parse_ornament
        parse_composition=Helper.parse_composition
        parse_sargam_pitch=Helper.parse_sargam_pitch
        parse_beat_delimited=Helper.parse_beat_delimited
        parse_beat_undelimited=Helper.parse_beat_undelimited
        parse_measure=Helper.parse_measure
        parse_sargam_line=Helper.parse_sargam_line
        extract_lyrics=Helper.extract_lyrics
        mark_partial_measures= Helper.mark_partial_measures
        measure_dashes_at_beginning_of_beats= Helper.measure_dashes_at_beginning_of_beats
        measure_note_durations= Helper.measure_note_durations
        count_beat_subdivisions = Helper.count_beat_subdivisions
        parens_unbalanced = Helper.parens_unbalanced
        get_source_for_items = Helper.get_source_for_items
        measure_columns = Helper.measure_columns
        assign_attributes=Helper.assign_attributes
        assign_lyrics=Helper.assign_lyrics
        collect_nodes = Helper.collect_nodes
        map_nodes = Helper.map_nodes
        check_semantics=Helper.check_semantics
        measure_pitch_durations=Helper.measure_pitch_durations
        if (typeof require !== 'undefined') {
          // x=require('./tree_iterators.js')
          all_items=require('./all_items.js').all_items
        }
        log = Helper.log
        // end of mixin section
        warnings=[]
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var errorPosition = computeErrorPosition();
        throw new this.SyntaxError(
          buildErrorMessage(),
          errorPosition.line,
          errorPosition.column
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(message, line, column) {
    this.name = "SyntaxError";
    this.message = message;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();
